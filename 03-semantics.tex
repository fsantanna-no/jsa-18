\section{Formal Semantics of \CEU}
\label{sec.sem}

We now introduce and formalize the semantics of a reduced version of \CEU,
called \emph{basic \CEU}.  Although simpler than the full language presented
in Section~\ref{sec.ceu}, basic \CEU is expressive enough to capture all the
essential characteristics of full \CEU, in particular, the stack-based
execution of internal events.  Once basic \CEU is defined, the more
elaborate constructs of full \CEU can be defined on top of it, as we will
discuss shortly.

The statements of basic \CEU are presented in Figure~\ref{fig.sem.syntax}.
In the figure, the metavariables~$v$ (ln~1, 2, 16), $e$ (ln~3--5, 10),
and~$n$ (ln~15--16) range over variable identifiers, event identifiers, and
integers.  The metavariable~$\stmt$ (ln~1, 7--13, 16--19) denotes a
statement, i.e., any of the statements of
Figure~\ref{fig.sem.syntax}---complex statements are defined recursively in
terms of simpler statements.  Finally, the metavariable $\expr$ (ln~2, 7)
denotes an expression.

\begin{figure}[ht!]
\begingroup
\setlength{\jot}{0pt}
\def\N#1{\mathllap{\text{\scriptsize{#1}}\hspace{1em}}}
\begin{empheq}[box=\fbox]{alignat*=3}
     \N1&\hskip4pt&&\ceu{\Var{v\,\stmt}}
                                    &\quad&\text{\it variable declaration}\\
     \N2&&&\ceu{v\coloneqq\expr}         &&\text{\it assignment statement}\\
     \N3&&&\ceu{\AwaitExt(e)}            &&\text{\it await external event}\\
     \N4&&&\ceu{\AwaitInt(e)}            &&\text{\it await internal event}\\
     \N5&&&\ceu{\EmitInt(e)}             &&\text{\it emit internal event}\\
     \N6&&&\ceu{\Break}                  &&\text{\it loop escape}\\
     \N7&&&\ceu{\IfElse{\expr}{\stmt_1}{\stmt_2}} &&\text{\it conditional}\\
     \N8&&&\ceu{\stmt_1\,;\,\stmt_2}     &&\text{\it sequence}\\
     \N9&&&\ceu{\Loop \stmt}             &&\text{\it infinite loop}\\
  \N{10}&&&\ceu{\Every{e}\,\stmt}        &&\text{\it event iteration}\\
  \N{11}&&&\ceu{\stmt_1\ParAnd\stmt_2}   &&\text{\it par/and statement}\\
  \N{12}&&&\ceu{\stmt_2\ParOr\stmt_2}    &&\text{\it par/or statement}\\
  \N{13}&&&\ceu{\Fin\stmt}               &&\text{\it finalization statement}\\
  \N{14}&&&\ceu{\Nop}                    &&\text{\it dummy statement}\\
  \N{15}&&&\ceu{\RunAt(n)}               &&\text{\it run at stack level~$n$}\\
  \N{16}&&&\ceu{\AtVar{v\,n\,\stmt}}     &&\text{\it expanded var}\\
  \N{17}&&&\ceu{\stmt_1\AtLoop\stmt_2}   &&\text{\it expanded loop}\\
  \N{18}&&&\ceu{\stmt_1\AtParAnd\stmt_2} &&\text{\it expanded par/and}\\
  \N{19}&&&\ceu{\stmt_1\AtParOr\stmt_2}  &&\text{\it expanded par/or}
\end{empheq}
\endgroup
\caption{The statements of basic \CEU.}
\label{fig.sem.syntax}
\end{figure}

For simplicity, we only consider integer expressions.  These are build up
from integer constants and variables by the usual mathematical operators
($+$, $-$, $\le$, \ldots).  We assume that expression evaluation takes zero
time (in accordance with the synchronous hypothesis) and that it always
produces an integer value.  In places where a boolean value is expected, any
nonzero value means true while zero means false.

We distinguish between three kinds of basic \CEU statements.  First, there
are those statements which are common in imperative languages and behave as
usual, namely, declarations, assignments, conditionals, sequences, loops,
and breaks.  (The $\ceu{\Var}$ statement of basic \CEU introduces a single
local variable whose scope is the statement immediately following it.)

The statements of the second kind are those which are specific to \CEU.
These are the statements $\ceu{\AwaitExt}$, $\ceu{\AwaitInt}$,
$\ceu{\EmitInt}$, and $\ceu{\Every}$, which deal with events, the statements
$\ceu{\ParAnd}$ and~$\ceu{\ParOr}$, which define parallel compositions, and
the statement~$\ceu{\Fin}$, which defines a finalization block.  These basic
\CEU statements are more or less equivalent to their counterparts in full
\CEU.  We defer a precise description of their behavior and entailed
properties to Section~\ref{sec.sem.opsem}.

Finally, the statements of the third kind are the remaining ones, namely,
$\ceu{\Nop}$, $\ceu{\RunAt}$, $\ceu{\AtVar}$, $\ceu{\AtLoop}$,
$\ceu{\AtParAnd}$, and $\ceu{\AtParOr}$.  These are hidden internal
statements used by the interpreter to encode in the program's text
information about its execution.  We will have more to say about these
\texttt{@}-statements in Section~\ref{sec.sem.opsem}.  Before that, however,
we need to present the syntactical restrictions of basic \CEU and discuss
the mapping of full \CEU programs into basic \CEU programs.

\subsection{Syntactic Restrictions of Basic \CEU}
\label{sec.sem.restrictions}

The syntax of basic \CEU shown in Figure~\ref{fig.sem.syntax} can be seen as
a schema for generating programs.  Not all programs generated by this schema
are well-formed though.  To be considered a \emph{well-formed} basic \CEU
program, the generated program must satisfy the following restrictions:
\begin{enumerate}
\item\label{sec.sem.restrictions.1} If variable~$v$ occurs in an expression
  or assignment statement of the program, then this occurrence happens in
  the body of a~$\ceu{\Var}$ statement that declares~$v$.
\item\label{sec.sem.restrictions.2} If a~$\ceu{\Break}$ occurs in the
  program, then this occurrence happens in the body of a~$\ceu{\Loop}$.
\item\label{sec.sem.restrictions.3} If a statement of the
  form~$\ceu{\Loop{\stmt}}$ occurs in the program, then all execution paths
  within~$\stmt$ contain a matching~$\ceu{\Break}$ or an~$\ceu{\AwaitExt}$
  or an~$\ceu{\Every}$.
\item\label{sec.sem.restrictions.4} If a statement of the
  form~$\ceu{\Every{e}\,{\stmt}}$ or~$\ceu{\Fin{\stmt}}$ occurs in the
  program, then~$\stmt$ does not contain occurrences of $\ceu{\Loop}$,
  $\ceu{\Break}$, $\ceu{\AwaitExt}$, $\ceu{\AwaitInt}$, $\ceu{\Every}$,
  or~$\ceu{\Fin}$.
\end{enumerate}

Restrictions~\ref{sec.sem.restrictions.1} and~\ref{sec.sem.restrictions.2}
prevent the use of undeclared variables or orphan~$\ceu{\Break}$'s.
Restriction~\ref{sec.sem.restrictions.3} ensures that the program does not
have an infinite loop with a body that runs in zero time (which would
violate the synchronous hypothesis).  And
restriction~\ref{sec.sem.restrictions.4} ensures that the body of
$\ceu{\Every}$ and~$\ceu{\Fin}$ statements always execute to completion
within the same reaction.  Similar restrictions exist in full \CEU, as
discussed in Section~\ref{sec.ceu}.

From now on, whenever we speak of a basic \CEU program we mean a well-formed
basic \CEU program.

\subsection{From Full \CEU to Basic \CEU}
\label{sec.sem.concrete}

Most statements of full \CEU are also present in basic \CEU.  These statements
in common, however, are not exactly equivalent.  It is sometimes the case
that a statement of full \CEU (say~\code{await}) has more features than its
basic \CEU counterpart ($\ceu{\AwaitInt}$).  In this section, we discuss how
the extra features of full \CEU are implemented in basic \CEU.

\subsubsection*{Await and emit}

The \code{await} and \code{emit} primitives of full \CEU are slightly more
complex than those of basic \CEU, as they support communication of values
between them.

Figure~\ref{lst.await_emit} shows a translation that adds a variable to hold
the value being communicated.
%
The original full \CEU code in Listing~\ref{lst.await_emit.a} declares an
internal event \code{e} (ln~2) and has an \code{await} (ln~4) and an
\code{emit} (ln~10) that communicate the value~$1$ between the trails in
parallel.
%
The translation to basic \CEU in Listing~\ref{lst.await_emit.b} declares an
additional shared variable \code{e\_} (ln~1) to hold the emitted value
(ln~9) and which can be accessed by the awaking trail (ln~5).

External events require a similar translation, i.e., each event needs a
corresponding global variable shared between all awaiting trails.

\begin{figure}[ht!]
\begin{minipage}[t]{0.48\linewidth}
\begin{lstlisting}[
    numbers=right,
    basicstyle=\ttfamily\small,
    caption={\,},
    label={lst.await_emit.a},
]

event int e;
par/or do
  var int v = await e;

  <...>
with
  <...>

  emit e(1);
end
\end{lstlisting}
\end{minipage}
%
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[
    xleftmargin=1.75em,
    basicstyle=\ttfamily\small,
    caption={\,},
    label={lst.await_emit.b},
]
var int e_;
event int e;
par/or do
  await e;
  var int v = e_;
  <...>
with
  <...>
  e_ = 1;
  emit e;
end
\end{lstlisting}
\end{minipage}
%
\caption{Full-to-Basic translation for \code{await} and \code{emit}. }
\label{lst.await_emit}
\end{figure}

\subsubsection*{First-class timers}

To add support for first-class timers to basic \CEU , we introduce a
\code{TIMER} input event, which notifies the passage of time, and two global
variables: \code{timer\_}, which holds the elapsed time, and \code{delta\_},
which holds the residual time (initially set to 0).

Listing~\ref{lst.TIMER.b} shows the basic \CEU program resulting from the
translation of the two timers shown in Listing~\ref{lst.TIMER.a} (ln~1--11).
A timer first adds a (possibly) negative delta from the time it should await
(ln~1).  Then, it enters in a loop that awakes on every occurrence of
\code{TIMER} (ln~7) and decrements the time it should await (ln~8).  Each
iteration of the loop checks if the timer has expired (ln~3), and sets the
new delta, which may affect a timer in sequence.  The check happens before
the await because the timer may already start expired due to the residual
time.

\begin{figure}[!ht]
\begin{minipage}[t]{0.33\linewidth}
\begin{lstlisting}[
    numbers=right,
    basicstyle=\ttfamily\small,
    caption={\,},
    label={lst.TIMER.a},
]
await 10ms;









await 1ms;

\end{lstlisting}
\end{minipage}
%
\begin{minipage}[t]{0.63\linewidth}
\begin{lstlisting}[
    xleftmargin=1.75em,
    basicstyle=\ttfamily\small,
    caption={\,},
    label={lst.TIMER.b},
]
var int tot_ = 10000 + delta_;
loop do
    if tot_ <= 0 then
        delta_ = tot_;
        break;
    end
    await TIMER;
    tot_ = tot_ - timer_;
end

var int tot_ = 1000 + delta_;
<...> // same loop as above
\end{lstlisting}
\end{minipage}
\caption{ Full-to-Basic translation for timers. }
\label{lst.TIMER}
\end{figure}

\subsubsection*{Finalization}

% Finally, a ``\code{finalize $A$ with $B$ end; $C$}'' in the concrete
% language is equivalent to ``\ceu{A;\;((\Fin{B})\ \ParOr\ C)}'' in the abstract
% language.  In the concrete language, $A$ and~$C$ execute in sequence, and
% the finalization code~$B$ is implicitly suspended waiting for~$C$
% to terminate.  In the abstract language, ``$\ceu{\Fin B}$'' suspends forever
% when reached (it is an awaiting statement that never awakes).  Hence, we
% need an explicit \code{or} to execute~$C$ in parallel, whose termination
% aborts ``$\ceu{\Fin B}$'', which finally causes~$B$ to execute (by the
% semantic rules below).

The biggest mismatch between full \CEU and basic \CEU is in their support
for finalization, i.e., between the statements \code{finalize} of full \CEU
and $\ceu{\Fin}$ of basic \CEU.
%
Listing~\ref{3.lst.fin.a} shows a full \CEU program containing an explicit
block (ln~1--8) that executes the statements in \code{<A>} (ln~3) immediately
followed by \code{<C>} (ln~7), and unconditionally executes \code{<B>}
(ln~5) when the block terminates or aborts.
%
To simulate this behavior in basic \CEU we need to perform the translation
shown in Listing~\ref{3.lst.fin.b}.  The basic \CEU code also executes
\code{<A>} (ln~1) immediately followed by \code{<C>} (ln~5).  The difference
is that the basic \code{fin <B>} statement (ln~3) blocks the pending statement
forever, which only awakes and executes when it is aborted.  The
\code{par/or} (ln~2--6) serves this purpose since it allows \code{<C>} to
execute immediately and aborts the \code{fin} when terminating.

\begin{figure}[ht!]
\begin{minipage}[t]{0.48\linewidth}
\begin{lstlisting}[
    numbers=right,
    basicstyle=\ttfamily\small,
    caption={\,},
    label={3.lst.fin.a},
]
do
    finalize
        <A>
    with
        <B>
    end
    <C>
end
\end{lstlisting}
\end{minipage}
%
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[
    xleftmargin=1.75em,
    basicstyle=\ttfamily\small,
    caption={\,},
    label={3.lst.fin.b},
]
<A>
par/or do
    fin <B>
with
    <C>
end


\end{lstlisting}
\end{minipage}
%
\caption{Full-to-Basic translation for finalization. }
\label{3.lst.fin}
\end{figure}

\subsection{Operational Semantics}
\label{sec.sem.opsem}

We proceed to formalize the operation of the basic \CEU interpreter.  Our
goal here is twofold.  First, we want to define a function~$\reaction$ that
describes precisely the operation steps taken by the interpreter to compute
a single reaction to an external event.  Second, we want to establish
(prove) some properties of this function.  In particular, we want to
establish that:
\begin{enumerate}
\item $\reaction$ is indeed a function: the same program will always react
  in the same way to a same external event (i.e., reactions are
  deterministic);
\item $\reaction$ is a total function: its computation always yields a
  result (i.e., reactions terminate); and
\item $\reaction$ can be computed by a linear bounded automaton: the amount
  of memory it uses never exceeds a fixed threshold which depends solely on
  the input program (i.e., reactions are memory-bounded).
\end{enumerate}

We will define $\reaction$ using a set of rules for a small-step operational
semantics~\cite{Plotkin-G-D-1981}.  These rules dictate how the internal
state of the basic \CEU interpreter progresses while it is computing a
reaction.  A snapshot of this internal state is called a \emph{description},
denoted~$\delta$, and consists of a quadruple~$\<\stmt,\ell,e,\theta>$ where
\begin{itemize}
\item $\stmt$ is a well-formed basic \CEU program;
\item $\ell$ is a nonnegative integer, called the stack level;
\item $e$ is an event identifier or the empty identifier~$\nil$;
  and
\item $\theta$ is a memory.
\end{itemize}

We will detail the precise meaning and purpose of the components of the
description in due course.  For now, the important thing is that the steps
taken by the interpreter to compute a reaction can be viewed as transitions
between descriptions.  The transitions are dictated by rules hardcoded in
the interpreter.  Each rule establishes that when the interpreter is in a
description~$\delta$ and certain criteria are met, then it will
\emph{transition} to a modified description~$\delta'$, in symbols,
\[
  \delta\trans\delta'.
\]
We call the description on the left-hand side of the symbol~$\trans$ the
\emph{input description}, and the one on its right-hand side the
\emph{output description}.

After transitioning to a modified description, the interpreter repeats the
rule-evaluation/transition process, and continues to do so until a final
description is reached.  This final description, called an \emph{irreducible
  description}, embodies the result of the reaction.

A full \emph{reaction} is thus defined as a sequence of the transitions of
the form
\[
  \delta_0\trans\delta_1\trans\cdots\trans\delta_f.
\]
The initial description~$\delta_0=\<\stmt_0,0,e,\theta_0>$ contains the
three inputs of the reaction: the text of the program at the beginning of
the reaction ($\stmt_0$), the event~$e$ to which the program must react, and
the memory~$\theta_0$ holding the values of the variables of~$\stmt_0$.  The
final description~$\delta_f=\<stmt_f,0,\nil,\theta_f>$ contains the two
outputs of the reaction: the text of the program at the end of the reaction
($\stmt_f$) and the memory~$\theta_f$ holding the values of the variables
of~$\stmt_f$ at the end of the reaction.  The output program~$\stmt_f$ and
memory~$\theta_f$ become inputs for the next reaction.

We write~$\delta_0\trans[i]\delta_f$ to indicate that $\delta_0$ leads
to~$\delta_f$ after exactly~$i$ transitions, and we
write~$\delta_0\trans[*]\delta_f$ to indicate that it does so after an
unspecified but finite number of transitions.  Using this notation, we can
define function~$\reaction$ (the first part of our goal) as follows:
\begin{align*}
  &\reaction(\stmt_0,\theta_0,e)=\<\stmt_f,\theta_f>\\
  &\quad\text{if (and only if)}\quad
    \<\stmt_0,0,e,\theta_0>\trans[*]\<\stmt_f,0,\nil,\theta_f>,
\end{align*}
where~$\<\stmt_f,0,\nil,\theta_f>$ is an irreducible description.  Under
this definition, $\reaction$ will be deterministic, terminating, and
memory-bounded (the second part of goal) if relation~$\trans[*]$ happens to
be so.  That this is the case is a consequence of the way transitions are
defined, as we will see in Section~\ref{sec.proofs}.

The next two sections, Sections~\ref{sec.sem.outermost}
and~\ref{sec.sem.nested}, give the rules for transitions.  There are two
types of transitions: \emph{outermost transitions} $\out$ and \emph{nested
  transitions} $\nst$.  The rules for~$\out$ and~$\nst$ transitions are
listed all at once in Figure~\ref{fig.rules}.  Each of these rules has the
form
\[
  \AxiomC{\strut condition$_1$}
  \AxiomC{\strut condition$_2$}
  \AxiomC{$\cdots$}
  \AxiomC{\strut condition$_n$}
  \QuaternaryInfC{$\delta\trans\delta'$}
  \DisplayProof
\]
and establishes that a transition~$\delta\trans\delta'$ shall take place if
condition$_1$, condition$_2$, \dots, and condition$_n$ are all true.  If the
number of conditions is zero, then the line is omitted and the rule is
called an axiom.

\subsection{Outermost Transitions}
\label{sec.sem.outermost}

The rules \R{push} and \R{pop} for~$\out$ transitions (see
Figure~\ref{fig.rules}) are non-recursive definitions that apply to the
program as a whole.  These are the only rules that manipulate the stack
level---the component of descriptions that determines the order of execution
of internal reactions.

\gl{\textbf{Pergunta:} ``Internal reaction'' (do jeito que está sendo usado
  aqui e abaixo) é a mesma coisa que ``nested reaction''?}

% \begin{gather*}
%   \AxiomC{$e\ne\nil$}
%   \UnaryInfC{$\<\stmt,n,e,\theta>\out\<\bcast(\stmt,e),n+1,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{push}\\
%   %%
%   \AxiomC{$n>0$}
%   \AxiomC{$\stmt=\ceu{\Nop}\lor\isblk(\stmt,n)$}
%   \BinaryInfC{$\<\stmt,n,\nil,\theta>\out\<\stmt,n-1,\nil,\theta>$}
%   \Rtag{pop}
%   \DisplayProof
% \end{gather*}

Rule \R{push} matches whenever there is a nonempty event in the input
description; it instantly broadcasts the event to the program, which means
it:
\begin{enumerate*}[label=(\roman*)]
\item uses function~$\bcast$ (defined below) to awake active
  $\ceu{\AwaitExt}$, $\ceu{\AwaitInt}$, or $\ceu{\Every}$ statements;
\item creates a nested reaction by increasing the stack level ($\ell$
  becomes~$\ell+1$); and
\item consumes the input event ($e$ becomes~$\nil$).
\end{enumerate*}
(Note that \R{push} is the only rule that matches a nonempty event in the
input description.)

Function~$\bcast$ is defined as follows:
\begin{align*}
  \bcast(\ceu{\AwaitExt(e)},e)
  &=\ceu{\Nop}\\
  %%
  \bcast(\ceu{\AwaitInt(e)},e)
  &=\ceu{\Nop}\\
  %%
  \bcast(\ceu{\Every{e}\ {\stmt}},e)
  &=\ceu{\stmt;\Every{e}\ {\stmt}}\\
  %%
  \bcast(\ceu{\stmt_1;\stmt_2},e)
  &=\ceu{\bcast(\stmt_1,e);\stmt_2}\\
  %%
  \bcast(\ceu{\AtVar{v\,n\,\stmt}})
  &=\ceu{\AtVar{v\,n\,\bcast(\stmt,e)}}\\
  %%
  \bcast(\ceu{\stmt_1\AtLoop{\stmt_2}},e)
  &=\ceu{\bcast(\stmt_1,e)\AtLoop{\stmt_2}}\\
  %%
  \bcast(\ceu{\stmt_1\AtParAnd{\stmt_2}},e)
  &=\\[-1\jot]
  &\hskip-3em\ceu{{\bcast(\stmt_1,e)}\AtParAnd{\bcast(\stmt_2,e)}}\\
  %%
  \bcast(\ceu{\stmt_1\AtParOr{\stmt_2}},e)
  &=\\[-1\jot]
  &\hskip-3em\ceu{{\bcast(\stmt_1,e)}\AtParOr{\bcast(\stmt_2,e)}}\\
  %%
  bcast(\_,e)&=\_\quad\text{\emph{(otherwise)}}
\end{align*}
where the underscore ($\_$) denotes the omitted patterns.  Function $\bcast$
takes a statement and an event~$e$ and awakes any trails awaiting for~$e$ by
converting active~$\ceu{\protect\AwaitExt(e)}$
and~$\ceu{\protect\AwaitInt(e)}$ statements to~$\ceu{\protect\Nop}$ (and
thus consuming them) and by unwinding active
$\ceu{\protect\Every{e\,\stmt}}$ statements once.

Rule \R{pop} simply decreases the stack level by one; it can only be applied
if the program is blocked or terminated ($\stmt=\ceu{\Nop}$).  As we will
see, these two conditions ensure that an $\ceu{\EmitInt}$ only resumes after
its internal reaction completes and blocks at the current stack level.

In order to determine whether the program is blocked, \R{pop} uses
predicate~$\isblk$.  This predicate is~\emph{true} if all parallel branches
of the given program are blocked waiting for events, finalization clauses,
or certain stack levels; otherwise, it is false.  Predicate~$\isblk$ is
defined as follows:
\begin{align*}
  \isblk(\ceu{\AwaitExt(e)},n)
  &=\mathit{true}\\
  %% 
  \isblk(\ceu{\AwaitInt(e)},n)
  &=\mathit{true}\\
  %% 
  \isblk(\ceu{\Every{e}\ {\stmt}},n)
  &=\mathit{true}\\
  %% 
  \isblk(\ceu{\RunAt(m)},n)
  &=(n>m)\\
  %% 
  \isblk(\ceu{\Fin{\stmt}},n)
  &=\mathit{true}\\
  %% 
  \isblk(\ceu{\stmt_1;\stmt_2},n)
  &=\isblk(\stmt_1,n)\\
  %%
  \isblk(\ceu{\AtVar{v\,n\,\stmt}},n)
  &=\isblk(\stmt,n)\\
  %%
  \isblk(\ceu{\stmt_1\AtLoop{\stmt_2}},n)
  &=\isblk(\stmt_1,n)\\
  %% 
  \isblk(\ceu{\stmt_1\AtParAnd{\stmt_2}},n)
  &=\isblk(\stmt_1,n)\land\isblk(\stmt_2,n)\\
  %% 
  \isblk(\ceu{\stmt_1\AtParOr{\stmt_2}},n)
  &=\isblk(\stmt_1,n)\land\isblk(\stmt_2,n)\\
  %% 
  \isblk(\_,n)
  &=\mathit{false}\quad\text{\emph{(otherwise)}}
\end{align*}

%(determined via function $\isblk$, defined below)

At the beginning of a reaction, an external event is emitted, which triggers
rule \R{push}, immediately raising the stack level to~1.  At the end of the
reaction, the program will block or terminate and successive applications of
rule~\R{pop} will lead to an irreducible description with this same program
at stack level~0.

\begin{figure*}[t]
  \small
  \newcommand*\LBL[1]{\Rlabel{#1}}
  \setlength{\extrarowheight}{1.2em}
  \newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
  \begin{tabular}[t]{|ll|}
    \hline
    %% ---------------------------------------------------------------------
    \hfil\emph{Outermost transitions} & \hfil\emph{Emissions}\\
    %%
    \LBL{push}\hfil
    \AxiomC{$e\ne\nil$}%
    \UnaryInfC{$\<\stmt,\ell,e,\theta>%
    \out\<\bcast(\stmt,e),\ell+1,\nil,\theta>$}%
    \DisplayProof
    %% 
    &\LBL{emit-int}\hfil
    $\<\ceu{\EmitInt(e)},\ell,\nil,\theta>
    \nst\<\ceu{\RunAt(\ell)},\ell,e,\theta>$\\
    %% ---------------------------------------------------------------------
    \LBL{pop}\hfil
    \AxiomC{$n>0$}%
    \AxiomC{$\stmt=\ceu{\Nop}\lor\isblk(\stmt,n)$}%
    \BinaryInfC{$\<\stmt,\ell,\nil,\theta>%
    \out\<\stmt,\ell-1,\nil,\theta>$}%
    \DisplayProof
    %% 
    &\LBL{run-at}\hfil
    $\<\ceu{\RunAt(\ell)},\ell,\nil,\theta>
    \nst\<\ceu{\Nop},\ell,\nil,\theta>$\\
    %% --------------------------------------------------------------------
    \hfil\emph{Assignments \& conditionals} & \hfil\emph{Sequences}\\
    %%
    \LBL{assign}\hfil
    $\<\ceu{v\coloneqq{\expr}},\nil,\theta>
    \nst\<\ceu{\Nop},\nil,\memupdt(\theta,v,\memeval(\theta,\expr))>$
    %%
    &\LBL{seq-nop}\hfil
    $\<\ceu{\Nop;\stmt_2},\nil,\theta>\nst\<\stmt_2,\nil,\theta>$\\
    %%
    \LBL{if-true}\hfil
    \AxiomC{$\memeval(\theta,\expr)\ne0$}
    \UnaryInfC{$\<\ceu{\IfElse{\expr}{\stmt_1}{\stmt_2}},\nil,\theta>
    \nst\<\stmt_1,\nil,\theta>$}
    \DisplayProof
    %%
    &\Rlabel{seq-brk}\hfil
    $\<\ceu{\Break;\stmt_2},\nil,\theta>
    \nst\<\ceu{\Break},\nil,\theta>$\\
    %%
    \LBL{if-false}\hfil
    \AxiomC{$\memeval(\theta,\expr)=0$}
    \UnaryInfC{$\<\ceu{\IfElse{\expr}{\stmt_1}{\stmt_2}},\nil,\theta>
    \nst\<\stmt_2,\nil,\theta>$}
    \DisplayProof
    %%
    &\LBL{seq-adv}\hfil
    \AxiomC{$\<\stmt_1,\nil,\theta>\nst\<\stmt_1',e,\theta'>$}
    \UnaryInfC{$\<\ceu{\stmt_1;\stmt_2},\nil,\theta>
    \nst\<\ceu{\stmt_1';\stmt_2},e,\theta'>$}
    \DisplayProof\\
    %% ---------------------------------------------------------------------
    \hfil\emph{Variable declarations} & \hfil\emph{Loops}\\
    %%
    \LBL{var-expd}\hfil
    $\<\ceu{\Var{v\,\stmt}},\nil,\theta>
    \nst\<\ceu{\AtVar{v\,\bot\,\stmt}},\nil,\theta>$
    %%
    &\LBL{loop-expd}\hfil
    $\<\ceu{\Loop{\stmt}},\nil,\theta>
    \nst\<\ceu{\stmt\AtLoop{\stmt}},\nil,\theta>$\\
    %% ---------------------------------------------------------------------
    \LBL{var-nop}\hfil
    $\<\ceu{\AtVar{v\,n\,\Nop}},\nil,\theta>
    \nst\<\ceu{\Nop},\nil,\theta>$
    %%
    &\LBL{loop-nop}\hfil
    $\<\ceu{\Nop\AtLoop{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\Loop{\stmt_2}},\nil,\theta>$\\
    %% ---------------------------------------------------------------------
    \LBL{var-brk}\hfil
    $\<\ceu{\AtVar{v\,n\,\Break}},\nil,\theta>
    \nst\<\ceu{\Break},\nil,\theta>$
    %%
    &\LBL{loop-brk}\hfil
    $\<\ceu{\Break\AtLoop{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\Nop},\nil,\theta>$\\
    %% ---------------------------------------------------------------------
    \LBL{var-adv}\hfil
    \AxiomC{$\<\ceu{\stmt},\nil,(v,n){:}\theta>
    \nst\<\ceu{\stmt'},e,(v,n'){:}\theta'>$}
    \UnaryInfC{$\<\ceu{\AtVar{v\,n\,\stmt}},\nil,\theta>
    \nst\<\ceu{\AtVar{v\,n'\,\stmt'}},e,\theta'>$}
    \DisplayProof
    %%
    &\LBL{loop-adv}\hfil
    \AxiomC{$\<\stmt_1,\nil,\theta>\nst\<\stmt_1',e,\theta'>$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtLoop{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\stmt_1'\AtLoop{\stmt_2}},e,\theta'>$}
    \DisplayProof\\
    %% ---------------------------------------------------------------------
    \hfil\emph{Par/and} & \hfil\emph{Par/or}\\[-.8\extrarowheight]
    %%
    \LBL{par/and-expd} & \LBL{par/or-expd}\\[-.3\extrarowheight]
    %%
    \hfil{$
    \begin{aligned}
      &\<\ceu{\stmt_1\ParAnd{\stmt_2}},\ell,\nil,\theta>\\[-\jot]
      &\qquad\nst\<\ceu{\stmt_1\AtParAnd(\RunAt(\ell);\stmt_2)},
      \ell,\nil,\theta>
    \end{aligned}$}
    %%
    &\hfil{$
    \begin{aligned}
      &\<\ceu{\stmt_1\ParOr{\stmt_2}},\ell,\nil,\theta>\\[-\jot]
      &\qquad\nst\<\ceu{\stmt_1\AtParOr(\RunAt(\ell);\stmt_2)},
      \ell,\nil,\theta>
    \end{aligned}$}\\
    %% ---------------------------------------------------------------------
    \LBL{par/and-nop1} & \LBL{par/or-nop1}\\[-.9\extrarowheight]
    %%
    \hfil$\<\ceu{{\Nop}\AtParAnd{\stmt_2}},\nil,\theta>
    \nst\<\stmt_2,\nil,\theta>$
    %%
    &\hfil$\<\ceu{{\Nop}\AtParOr{\stmt_2}},\nil,\theta>
    \nst\<\clear(\stmt_2),\nil,\theta>$\\
    %%
    \LBL{par/and-nop2} & \LBL{par/or-nop2}\\[-.9\extrarowheight]
    %%
    \hfil\AxiomC{$\isblk(\stmt_1,\ell)$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtParAnd{\Nop}},\ell,\nil,\theta>
    \nst\<\stmt_1,\ell,\nil,\theta>$}
    \DisplayProof
    %%
    &\hfil\AxiomC{$\isblk(\stmt_1,\ell)$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtParOr{\Nop}},\ell,\nil,\theta>
    \nst\<\clear(\stmt_1),\ell,\nil,\theta>$}
    \DisplayProof\\
    %% ---------------------------------------------------------------------
    \LBL{par/and-brk1} & \LBL{par/or-brk1}\\[-.9\extrarowheight]
    %%
    \hfil$\<\ceu{{\Break}\AtParAnd{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\clear(\stmt_2);\Break},\nil,\theta>$
    %%
    &\hfil$\<\ceu{{\Break}\AtParOr{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\clear(\stmt_2);\Break},\nil,\theta>$\\
    %%
    \LBL{par/and-brk2} & \LBL{par/or-brk2}\\[-.9\extrarowheight]
    %%
    \hfil\AxiomC{$\isblk(\stmt_1,\ell)$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtParAnd{\Break}},\ell,\nil,\theta>
    \nst\<\ceu{\clear(\stmt_1);\Break},\ell,\nil,\theta>$}
    \DisplayProof
    %%
    &\hfil\AxiomC{$\isblk(\stmt_1,\ell)$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtParOr{\Break}},\ell,\nil,\theta>
    \nst\<\ceu{\clear(\stmt_1);\Break},\ell,\nil,\theta>$}
    \DisplayProof\\
    %% ---------------------------------------------------------------------
    \LBL{par/and-adv1} & \LBL{par/or-adv1}\\[-.9\extrarowheight]
    %%
    \hfil\AxiomC{$\<\stmt_1,\nil,\theta>\nst\<\stmt_1',e,\theta'>$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtParAnd{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\stmt_1'\AtParAnd{\stmt_2}},e,\theta'>$}
    \DisplayProof
    %%
    &\hfil\AxiomC{$\<\stmt_1,\nil,\theta>\nst\<\stmt_1',e,\theta'>$}
    \UnaryInfC{$\<\ceu{\stmt_1\AtParOr{\stmt_2}},\nil,\theta>
    \nst\<\ceu{\stmt_1'\AtParOr{\stmt_2}},e,\theta'>$}
    \DisplayProof\\
    %%
    \LBL{par/and-adv2} & \LBL{par/or-adv2}\\[-.5\extrarowheight]
    %%
    \hfil\AxiomC{$\isblk(\stmt_1,\ell)$}
    \AxiomC{$\<\stmt_2,\ell,\nil,\theta'>\nst\<\stmt_2',\ell,e,\theta'>$}
    \BinaryInfC{$\<\ceu{\stmt_1\AtParAnd{\stmt_2}},\ell,\nil,\theta>
    \nst\<\ceu{\stmt_1\AtParAnd{\stmt_2'}},\ell,e,\theta'>$}
    \DisplayProof
    %%
    &\hfil\AxiomC{$\isblk(\stmt_1,\ell)$}
    \AxiomC{$\<\stmt_2,\ell,\nil,\theta>\nst\<\stmt_2',\ell,e,\theta'>$}
    \BinaryInfC{$\<\ceu{\stmt_1\AtParOr{\stmt_2}},\ell,\nil,\theta>
    \nst\<\ceu{\stmt_1\AtParOr{\stmt_2'}},\ell,e,\theta'>$}
    \DisplayProof\\[2em]
    %%
    \hline
  \end{tabular}
  \caption{Rules for $\out$ and~$\nst$ transitions.}
  \label{fig.rules}
  \Rlabelhook
\end{figure*}

\subsection{Nested Transitions}
\label{sec.sem.nested}

The~$\nst$ transitions have the general form
\[
\<\stmt,n,\nil,\theta>\nst\<\stmt',n,e,\theta'>.
\]
They do not affect the stack level and never have an emitted event as a
precondition.  The distinction between~$\out$ and~$\nst$ prevents rules
\R{push} and \R{pop} from matching and, consequently, from inadvertently
modifying the stack level before the nested reaction is over.

A full reaction follows the pattern
%%
\begin{align*}
  \<\stmt_0,0,e_\ext,\theta_0>\outpush
  {\Big[{\nst[*]}{\out}\Big]{*}}
  \null\mathbin{\nst[*]\outpop}\<\stmt_f,0,\nil,\theta_f>.
\end{align*}
%%
First, a~$\outpush$ starts a nested reaction at level~1.  Then, a series of
alternations between zero or more~$\nst$ transitions (nested reactions) and
a single~$\out$ transition (stack operation) takes place.  Finally, zero or
more $\nst$ transitions followed by a last~$\outpop$ transition, which
decrements the stack level to~0, terminates the reaction.

We now describe the rules for nested transitions (also listed in
Figure~\ref{fig.rules}).  Since these rules do not affect the stack level,
whenever convenient, we will omit the stack level when writing them.  Thus,
in Figure~\ref{fig.rules}, we sometimes write descriptions as
triples~$\<\stmt,e,\theta>$ with the tacit understanding that there is a
hidden integer~$\ell$ for the stack level between the components~$\stmt$
and~$e$.

\subsubsection*{Declarations and assignments}

There are five $\nst$ rules for dealing with variables: \R{locals}, which
introduces a new block of declarations; \R{restore}, which makes a
previously introduced block go out of scope; and \R{assign}, which evaluates
an expression and assigns the resulting value to a variable.
%%
% \begin{gather*}
%   \<\ceu{\Locals{\vars\,\stmt}},\nil,\theta>
%   \nst\<\ceu{\stmt;\Restore(\left|\theta\right|)},\nil,\memdecl(\theta,\vars)>
%   \Rtag{locals}\\
%   %%
%   \<\ceu{\Restore(n)},\nil,\theta>
%   \nst\<\ceu{\Nop},\nil,\memrest(\theta,n)>
%   \Rtag{restore}\\
%   %%
%   \<\ceu{v\coloneqq{\expr}},\nil,\theta>
%   \nst\<\ceu{\Nop},\nil,\memupdt(\theta,v,\memeval(\theta,\expr))>
%   \Rtag{assign}
% \end{gather*}

The three rules, \R{locals}, \R{restore}, and~\R{assign}, act on the input
memory~$\theta$.  A \emph{memory} is a stack of environments
$[E_1,\dots,E_k]$ where each environment~$E_i$ is a set of bindings, i.e.,
pairs of the form~$(v,n)$ which associate a variable~$v$ to an integer
value~$n$.  For instance, the memory
\[
  \big[\{(v_1,1),(v_2,\bot)\},\,\{(v_1,0)\}\big]
\]
has two environments: $E_1=\{(v_1,1),(v_2,\bot)\}$ (top-of-stack)
and~$E_2=\{(v_1,0)\}$.  This memory tells us that, at some point,
variable~$v_1$ was declared and set to~0, and that later, in a nested scope,
$v_1$ was re-declared (shadowing the previous declaration) and~$v_2$ was
declared for the first time.  Still in the nested scope, which corresponds
to the most recent environment~$E_1$, variable~$v_1$ was set to~1 but~$v_2$
remained undefined, hence its value~$\bot$ (\emph{undefined}).

We use the following functions to manipulate memories (all of them return a
modified memory):
\begin{align*}
  \memdecl(\theta,v_1,,\dots,v_n)
  &=\{(v_1,\bot),\dots,(v_n,\bot)\}:\theta\\
  %%
  \memrest(\theta,n)
  &=\text{pops $\left|\theta\right|-n$ elements from~$\theta$}\\
  %%
  \memupdt(E{:}\theta,v,n)
  &=\begin{cases}
    \begin{aligned}[b]
      &((E-\{(v,n')\})\\
      &\quad\null\cup\{(v,n)\}):\theta
    \end{aligned}
    &\text{if~$(v,n')\in{E}$}\\
    %%
    \memupdt(\theta,v,n)
    &\text{otherwise}
  \end{cases}
\end{align*}
%%
The colon ($:$) stands for the list constructor operator---thus $E{:}\theta$
denotes the stack obtained by pushing~$E$
onto~$\theta$---and~$\left|\theta\right|$ stands for the length of
stack~$\theta$.

Function~$\memdecl$ pushes onto stack~$\theta$ a new environment in which
variables~$v_1$, \dots, $v_n$ are declared but not initialized.
Function~$\memrest$ restores stack~$\theta$ to index~$n$, dropping any
environments above this index.  And function~$\memupdt$ binds variable~$v$
to the integer~$n$ in the most recent environment where~$v$ occurs.

Back to the rules, \R{locals} transforms a statement of the form
$\ceu{\Locals{\vars\,\stmt}}$ into a sequence
$\ceu{\stmt;\Restore(\left|\theta\right|)}$ and pushes onto~$\theta$ a new
environment declaring all variables in~$\vars$.  The idea is that
after~$\stmt$ executes and the $\ceu{\Locals}$ block goes out of scope, the
memory is restored to its original length by the subsequent $\ceu{\Restore}$
statement (rule~\R{restore}), which effectively removes any environments
introduced by the $\ceu{\Locals}$ block and its body.

Rule~\R{assign} transforms~$\ceu{v\coloneqq\expr}$ into $\ceu{\Nop}$ (the
dummy statement) and performs the assignment.  That is, it evaluates~$\expr$
to an integer~$n$ and assigns~$n$ to variable~$v$ in the most recent
environment where~$v$ was declared.

Expression evaluation is carried out by function~$\memeval$.  For
simplicity, we assume that~$\memeval$ always returns an integer.  In
practice, any error in the evaluation, such as access to an uninitialized
variable or division by zero, will cause the interpreter to abort.

\subsubsection*{Emissions}

% \begin{gather*}
%   \<\ceu{\EmitInt(e)},n,\nil,\theta>
%   \nst\<\ceu{\RunAt(n)},n,e,\theta>\Rtag{emit-int}\\
%   %%
%   \<\ceu{\RunAt(n)},n,\nil,\theta>
%   \nst\<\ceu{\Nop},n,\nil,\theta>\Rtag{run-at}
% \end{gather*}

An $\ceu{\EmitInt(e)}$ generates event~$e$ and becomes a
$\ceu{\RunAt(\ell)}$ statement (rule \R{emit-int}); this
$\ceu{\RunAt(\ell)}$ statement only resumes at stack level~$\ell$ (rule
\R{run-at}).

Since every~$\nst$ rule expects the input event to be empty, an application
of \R{emit-int} leads immediately to an application of \R{push} at the outer
level, creating a new level~$\ell+1$ on the stack.  With this new stack
level, the $\ceu{\RunAt}(\ell)$ resulting from the $\ceu{\EmitInt(e)}$ can
only transition after future applications of~\R{pop} put the stack level
back in~$\ell$.  This interplay between \R{emit-int}, \R{push}, \R{pop}, and
\R{run-at} provides the desired stack-based semantics for internal events.

\subsubsection*{Conditionals}

% \begin{gather*}
%   \AxiomC{$\memeval(\theta,\expr)\ne0$}
%   \UnaryInfC{$\<\ceu{\IfElse{\expr}{\stmt_1}{\stmt_2}},\nil,\theta>
%     \nst\<\stmt_1,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{if-true}\\
%   %%
%   \AxiomC{$\memeval(\theta,\expr)=0$}
%   \UnaryInfC{$\<\ceu{\IfElse{\expr}{\stmt_1}{\stmt_2}},\nil,\theta>
%     \nst\<\stmt_2,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{if-false}
% \end{gather*}

Rules \R{if-true} and \R{if-false} transform a conditional statement into
its if-part ($\stmt_1$) or else-part ($\stmt_2$) depending on the value to
which the associated expression ($\expr$) evaluates in the current memory.
If it evaluates to a nonzero value, then \R{if-true} applies and the
conditional becomes~$\stmt_1$; otherwise, \R{if-false} applies and the
conditional becomes~$\stmt_2$.  These are the only rules that use the
contents of the memory in a way that affects the control flow.

\subsubsection*{Sequences}

% \begin{gather*}
%   \<\ceu{\Nop;\stmt_2},\nil,\theta>
%   \nst\<\stmt_2,\nil,\theta>
%   \Rtag{seq-nop}\\
%   %%
%   \<\ceu{\Break;\stmt_2},\nil,\theta>
%   \nst\<\ceu{\Break},\nil,\theta>\Rtag{seq-brk}\\
%   %%
%   \AxiomC{$\<\stmt_1,\nil,\theta>\nst\<\stmt_1',e,\theta'>$}
%   \UnaryInfC{$\<\ceu{\stmt_1;\stmt_2},\nil,\theta>
%     \nst\<\ceu{\stmt_1';\stmt_2},e,\theta'>$}
%   \DisplayProof
%   \Rtag{seq-adv}
% \end{gather*}

A sequence whose first part is terminated ($\ceu{\Nop}$) becomes its second
part (rule \R{seq-nop}).  A sequence whose first part is a~$\ceu{\Break}$,
propagates the~$\ceu{\Break}$ by dropping its second part (rule
\R{seq-brk}).  And a sequence whose first part is neither $\ceu{\Nop}$
nor~$\ceu{\Break}$ advances to the sequence, event, and memory resulting
from advancing just its first part (rule \R{seq-adv}).

\subsubsection*{Loops}

% \begin{gather*}
%   \<\ceu{\Loop{\stmt}},\nil,\theta>
%   \nst\<\ceu{(\stmt\AtLoop{\stmt});
%     \Restore({\left|\theta\right|})},\nil,\theta>
%   \Rtag{loop-expd}\\
%   %%
%   \<\ceu{\Nop\AtLoop{\stmt_2}},\nil,\theta>
%   \nst\<\ceu{\Loop{\stmt_2}},\nil,\theta>
%   \Rtag{loop-nop}\\
%   %%
%   \<\ceu{\Break\AtLoop{\stmt_2}},\nil,\theta>
%   \nst\<\ceu{\Nop},\nil,\theta>
%   \Rtag{loop-brk}\\
%   %%
%   \AxiomC{$\<\stmt_1,\nil,\theta>\nst\<\stmt_1',e,\theta'>$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtLoop{\stmt_2}},\nil,\theta>
%     \nst\<\ceu{\stmt_1'\AtLoop{\stmt_2}},e,\theta'>$}
%   \DisplayProof
%   \Rtag{loop-adv}
% \end{gather*}

When the interpreter encounters a $\ceu{\Loop}$, it expands its body in
sequence with the loop itself followed by a $\ceu{\Restore}$ statement (rule
\R{loop-expd}).  The $\ceu{\Restore}$ statement ensures that if the loop is
terminated by a $\ceu{\Break}$, any environments introduced by the loop are
popped from the memory.

The remaining rules for loops are similar to those for sequences but use
``\texttt{@}'' as separators to bind the current code of the loop to its
next iteration.  Rules \R{loop-nop} and \R{loop-adv} are analogous to rules
\R{seq-nop} and \R{seq-adv}.  They advance the current code of the loop
until it becomes a~$\ceu{\Nop}$.  When this happens the loop is restarted
(\R{seq-nop}).  (Note that if we had used ``\texttt{;}'' as a separator in
loops, rules \R{loop-brk} and \R{seq-brk} would conflict.)  Finally, rule
\R{loop-brk} escapes the enclosing loop, transforming everything into
a~$\ceu{\Nop}$.

\strut\fs{Cheguei até aqui.}

\subsubsection*{Par/and and par/or compositions}

% \begin{gather*}
%   \begin{split}
%     &\<\ceu{\stmt_1\ParAnd{\stmt_2}},n,\nil,\theta>\\
%     &\qquad\null\nst\<\ceu{\stmt_1\AtParAnd(\RunAt(n);\stmt_2)},n,\nil,\theta>
%   \end{split}
%   \Rtag{par/and-expd}\\
%   %%
%   \begin{split}
%     &\<\ceu{\stmt_1\ParOr{\stmt_2}},n,\nil,\theta>\\
%     &\qquad\null\nst\<\ceu{(\stmt_1\AtParOr(\RunAt(n);\stmt_2));
%       \Restore(\left|\theta\right|)},n,\nil,\theta>
%   \end{split}
%   \Rtag{par/or-expd}
% \end{gather*}

When first encountered by the interpreter, $\ceu{\ParAnd}$ and
$\ceu{\ParOr}$ are immediately expanded to their internal versions
$\ceu{\AtParAnd}$ and~$\ceu{\AtParOr}$ by rules~\R{par/and-expd}
and~\R{par/or-expd}.  These rules prefix a~$\ceu{\RunAt(n)}$ to the
right-hand side of the compositions to ensure that any
reachable~$\ceu{\EmitInt}$ on the left-hand side executes to completion
before the right-hand side starts.

Rule~\R{par/or-expd} also appends a $\ceu{\Restore}$ to the resulting
$\ceu{\AtParOr}$.  This ensures that old environments left by an aborted
side are cleaned up when the $\ceu{\AtParOr}$ terminates.  This is not
necessary in rule \R{par/and-expd} because a $\ceu{\ParAnd}$ terminates only
after \emph{both} of its sides terminate, i.e., both sides will always run
to completion, making any $\ceu{\Locals}$ block go out of scope.  But the
same is not true for $\ceu{\ParOr}$, which terminates when \emph{any} of its
sides terminates.

There are twelve rules for advancing the sides of the
internal~$\ceu{\AtParAnd}$ and~$\ceu{\AtParOr}$ statements.  Each of these
rules ensures that the left-hand side always advances before the right-hand
side.  That is, in each rule the right-hand side is advanced only when the
left-hand side is blocked.  The twelve rules are divided into three groups:
\begin{enumerate*}[label=(\roman*)]
\item those that apply when one of the sides is $\ceu{\Nop}$;
\item those that apply when one of the sides is $\ceu{\Break}$; and
\item those that apply when neither side is $\ceu{\Nop}$ or $\ceu{\Break}$.
\end{enumerate*}

We begin by presenting the rules of the last group, which do not involve the
termination of one of the sides.
%%
% \begin{gather*}
%   \AxiomC{$\<\stmt_1,n,\nil,\theta>\nst\<\stmt_1',n,e,\theta'>$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtParAnd{\stmt_2}},n,\nil,\theta>
%     \nst\<\ceu{\stmt_1'\AtParAnd{\stmt_2}},n,e,\theta'>$}
%   \DisplayProof
%   \Rtag{par/and-adv1}\\
%   %%
%   \AxiomC{$\isblk(\stmt_1,n)$}
%   \AxiomC{$\<\stmt_2,n,\nil,\theta'>\nst\<\stmt_2',n,e,\theta'>$}
%   \BinaryInfC{$\<\ceu{\stmt_1\AtParAnd{\stmt_2}},n,\nil,\theta>
%     \nst\<\ceu{\stmt_1\AtParAnd{\stmt_2'}},n,e,\theta'>$}
%   \DisplayProof
%   \Rtag{par/and-adv2}\\
%   %%
%   \AxiomC{$\<\stmt_1,n,\nil,\theta>\nst\<\stmt_1',n,e,\theta'>$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtParOr{\stmt_2}},n,\nil,\theta>
%     \nst\<\ceu{\stmt_1'\AtParOr{\stmt_2}},n,e,\theta'>$}
%   \DisplayProof
%   \Rtag{par/or-adv1}\\
%   %%
%   \AxiomC{$\isblk(\stmt_1,n)$}
%   \AxiomC{$\<\stmt_2,n,\nil,\theta>\nst\<\stmt_2',n,e,\theta'>$}
%   \BinaryInfC{$\<\ceu{\stmt_1\AtParOr{\stmt_2}},n,\nil,\theta>
%     \nst\<\ceu{\stmt_1\AtParOr{\stmt_2'}},n,e,\theta'>$}
%   \DisplayProof
%   \Rtag{par/or-adv2}
% \end{gather*}

Rules~\R{par/and-adv1} and \R{par/or-adv1} match whenever the left-hand side
of the composition is not blocked (see $\isblk$ in
Figure~\ref{fig.isblocked}).  They advance the composition the to the
statement, event, and memory resulting from advancing just its left-hand
side.  Rules~\R{par/and-adv2} and \R{par/or-adv2} are similar, but they act
on the right-hand side and match only when the left-hand side is blocked.

The next rules apply whenever one of the sides of the $\ceu{\AtParAnd}$ or
$\ceu{\AtParOr}$ terminates (becomes a $\ceu{\Nop}$).
%%
% \begin{gather*}
%   \<\ceu{{\Nop}\AtParAnd{\stmt_2}},n,\nil,\theta>
%   \nst\<\stmt_2,n,\nil,\theta>
%   \Rtag{par/and-nop1}\\
%   %%
%   \AxiomC{$\isblk(\stmt_1,n)$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtParAnd{\Nop}},n,\nil,\theta>
%     \nst\<\stmt_1,n,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{par/and-nop2}\\
%   %%
%   \<\ceu{{\Nop}\AtParOr{\stmt_2}},n,\nil,\theta>
%   \nst\<\clear(\stmt_2),n,\nil,\theta>
%   \Rtag{par/or-nop1}\\
%   %%
%   \AxiomC{$\isblk(\stmt_1,n)$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtParOr{\Nop}},n,\nil,\theta>
%     \nst\<\clear(\stmt_1),n,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{par/or-nop2}
% \end{gather*}

In a~$\ceu{\AtParAnd}$, if one of the sides terminates, the composition
becomes the other side (rules \R{par/and-nop1} and \R{par/and-nop2}).  In
a~$\ceu{\AtParOr}$, however, if one of the sides terminates, the whole
composition terminates and~$\clear$ is called to finalize the aborted side
(rules \R{par/or-nop1} and \R{par/or-nop2}).

The~$\clear$ function (see Figure~\ref{fig.clear}) returns the statement
resulting from sequencing the body of all active~$\ceu{\Fin}$ statements in
the aborted side.  This way all finalization code associated with the
aborted side executes immediately after the composition terminates.

(As there are no transition rules for~$\ceu{\Fin}$ statements, once reached,
a $\ceu{\Fin}$ halts and will only be consumed if its trail is aborted.  At
this moment, its body will execute as a result of the~$\clear$ call.  Note
that the syntactic restrictions of Section~\ref{sec.sem.restrictions} ensure
that the body of a~$\ceu{\Fin}$ statement always execute within the same
reaction.)

Finally, a~$\ceu{\Break}$ in one of the sides of a $\ceu{\AtParAnd}$ or
$\ceu{\AtParOr}$ is propagated, terminating the composition and properly
aborting the other side with a~$\clear$ call:
%%
% \begin{gather*}
%   \<\ceu{{\Break}\AtParAnd{\stmt_2}},n,\nil,\theta>
%   \nst\<\ceu{\clear(\stmt_2);\Break},n,\nil,\theta>
%   \Rtag{and-brk1}\\
%   %%
%   \AxiomC{$\isblk(\stmt_1,n)$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtParAnd{\Break}},n,\nil,\theta>
%     \nst\<\ceu{\clear(\stmt_1);\Break},n,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{and-brk2}\\[\baselineskip]
%   %%
%   \<\ceu{{\Break}\AtParOr{\stmt_2}},n,\nil,\theta>
%   \nst\<\ceu{\clear(\stmt_2);\Break},n,\nil,\theta>
%   \Rtag{or-brk1}\\
%   %%
%   \AxiomC{$\isblk(\stmt_1,n)$}
%   \UnaryInfC{$\<\ceu{\stmt_1\AtParOr{\Break}},n,\nil,\theta>
%     \nst\<\ceu{\clear(\stmt_1);\Break},n,\nil,\theta>$}
%   \DisplayProof
%   \Rtag{or-brk2}
% \end{gather*}

\begin{figure}[h]
\small
\begin{gather*}
  \boxed{
    \begin{align*}
      %%
      %%-
      \shortintertext{\llap{(i)~}Function~$\bcast$:}
      %%-
      %%
      \bcast(\ceu{\AwaitExt(e)},e)
      &=\ceu{\Nop}\\
      %%
      \bcast(\ceu{\AwaitInt(e)},e)
      &=\ceu{\Nop}\\
      %%
      \bcast(\ceu{\Every{e}\ {\stmt}},e)
      &=\ceu{\stmt;\Every{e}\ {\stmt}}\\
      %%
      \bcast(\ceu{\stmt_1;\stmt_2},e)
      &=\ceu{\bcast(\stmt_1,e);\stmt_2}\\
      %%
      \bcast(\ceu{\stmt_1\AtLoop{\stmt_2}},e)
      &=\ceu{\bcast(\stmt_1,e)\AtLoop{\stmt_2}}\\
      %%
      \begin{split}
        \bcast(\ceu{\stmt_1\AtParAnd{\stmt_2}},e)&=\\
        &\hskip-3em\ceu{{\bcast(\stmt_1,e)}\AtParAnd\bcast(\stmt_2,e)}
      \end{split}\\
      %%
      \begin{split}
        \bcast(\ceu{\stmt_1\AtParOr{\stmt_2}},e)&=\\
        &\hskip-3em\ceu{{\bcast(\stmt_1,e)}\AtParOr{\bcast(\stmt_2,e)}}
      \end{split}\\
      %%
      bcast(\_,e)
      &=\_\quad\text{\emph{(otherwise)}}\\[4\jot]
      %%
      %%-
      \shortintertext{\llap{(ii)~}Predicate~$\isblk$:}
      %%-
      %%
      %%
      %%-
      \shortintertext{\llap{(iii)~}Function~$\clear$:}
      %%-
      %%
      \clear(\ceu{\AwaitExt(e)})
      &=\ceu{\Nop}\\
      %%
      \clear(\ceu{\AwaitInt(e)})
      &=\ceu{\Nop}\\
      %%
      \clear(\ceu{\Every{e}\ \stmt})
      &=\ceu{\Nop}\\
      %%
      \clear(\ceu{\RunAt(n)})
      &=\ceu{\Nop}\\
      %%
      \clear(\ceu{\Fin{\stmt}})
      &=\stmt\\
      %%
      \clear(\ceu{\stmt_1;\stmt_2})
      &=\clear(\stmt_1)\\
      %%
      \clear(\ceu{\stmt_1\AtLoop{\stmt_2}})
      &=\clear(\stmt_1)\\
      %%
      \clear(\ceu{\stmt_1\AtParAnd{\stmt_2}})
      &=\ceu{\clear(\stmt_1);\clear(\stmt_2)}\\
      %%
      \clear(\ceu{\stmt_1\AtParOr{\stmt_2}})
      &=\ceu{\clear(\stmt_1);\clear(\stmt_2)}\\
      %%
      \clear(\_)
      &=\bot\quad\text{\emph{(undefined)}}
    \end{align*}}
\end{gather*}
\vskip-2\belowdisplayskip
\caption{%
  (i)~Function~$\bcast$ awakes awaiting trails matching the event by
  converting~$\ceu{\protect\AwaitExt}$ and~$\ceu{\protect\AwaitInt}$
  to~$\ceu{\protect\Nop}$, and by unwinding $\ceu{\protect\Every}$
  statements.
  %%
  \space(ii)~Predicate~$\isblk$ is true only if all branches in parallel
  are blocked waiting for events, finalization clauses, or certain
  stack levels.
  %%
  \space(iii)~Function~$\clear$ extracts~$\ceu{\protect\Fin}$ statements in
  parallel and put their bodies in sequence.
  %%
  In~(i), (ii), and~(iii),~``$\_$'' denotes the omitted patterns.  (Note
  that the syntactic restrictions ensure that $\clear$ is only called on
  inputs for which it is defined.)
}
\label{fig.bcast}
\label{fig.isblocked}
\label{fig.clear}
\end{figure}

\gl{Assim como as regras, estou pensando em mover as definições da
  Figura~\ref{fig.bcast} junto com $\memdecl$, $\memrest$, e $\memupdt$ para
  um quadrão de duas colunas.}

\subsection{Using the Rules to Compute Reactions}

We conclude the discussion of the rules for~$\out$ and~$\nst$ transitions
with an example of their application in the computation of reactions.

\begingroup
\newcommand*{\led}{\mathit{led}}
\newcommand*\evtboot{e_{\mathit{boot}}}
\newcommand*\evtbttn{e_{\mathit{bttn}}}
\newcommand*\evtrecv{e_{\mathit{recv}}}

Consider the the following basic \CEU program:
\begin{align*}
  &\ceu{\Locals{\,\led}}\\
  &\quad\ceu{\Big(\AwaitExt(\evtbttn)\Big)\enspace\ParOr\enspace}
  \begin{aligned}[t]
    \Big(&\ceu{\Loop}\enspace
    \begin{aligned}[t]
      \big(&\ceu{\led\coloneqq1;\AwaitExt(\evtrecv)};\\
       &\ceu{\led\coloneqq0;\AwaitExt(\evtrecv)}\big);\\
    \end{aligned}\\
    &\ceu{\Fin\,{\led\coloneqq0}}\Big)
  \end{aligned}
\end{align*}
This is simplified basic \CEU version of the full \CEU program presented in
Listing~\ref{lst.ceu}.  As its full \CEU counterpart, this program toggles a
LED whenever a radio packet (event~$\evtrecv$) is received, terminating on a
button press (event~$\evtbttn$) always with the LED off---the state of the
led is represented by variable~$\led$.

We will compute three reactions of the above program.  First, to the
bootstrap event~$\evtboot$ (the bootstrap reaction) and then to the external
events~$\evtrecv$ and~$\evtbttn$.  We will execute the reactions in series,
which means that the outputs of a reaction will become inputs of the next
reaction.

\newcommand*\ddd{\mathmakebox[1em][c]{.\hfil.\hfil.}}
\newcommand*\TRANS[2][]{\xrightarrow[#1]{\text{#2}}}

The bootstrap reaction starts with a description
\[
  \delta_0=\<\ceu{\Locals{\led}\,\ddd}\,,0,e_\text{boot},[]>,
\]
where~$\ceu{\Locals{\led}\,\ddd}$ is the original program, $e_\text{boot}$
is the bootstrap event, and~$[]$ is the empty memory, and proceeds as
follows:\footnote{In the $\nst$ transitions we underline the part of the
  statement matched by the rule.  In case the rule is recursive, we
  underline only the part matched by the basis of the recursion---the
  axiom---and write the name of this axiom in parentheses below the arrow
  representing the transition.}

\clearpage% <-- temporary
\begin{align*}
  \delta_0\TRANS{push}\null&
    \<\ceu{\uline{\Locals{\led}\,\ddd}}\,,1,\nil,[]>\\
    %%
  \TRANS{locals}\null&
    \<\ceu{\uline{(\ddd)\ParOr(\ddd)};\Restore(0)},1,\nil,[\{(\led,\bot)\}]>\\
    %%
  \TRANS{par/or-expd}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr(\uline{\RunAt(1)};\Loop\,\ddd);}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,\bot)\}]\rangle\\
    \end{aligned}\\
    %%
  \TRANS[\text{(run-at)}]{par/or-adv2}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr(\uline{\Nop;\Loop\,\ddd});}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,\bot)\}]\rangle\\
    \end{aligned}\\
    %%
  \TRANS[\text{(seq-nop)}]{par/or-adv2}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr(\uline{\Loop\,\ddd});}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,\bot)\}]\rangle\\
    \end{aligned}\\
    %%
  \TRANS[\text{(loop-expd)}]{par/or-adv2}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr
               (\uline{\led\coloneqq1};\ddd\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,\bot)\}]\rangle\\
    \end{aligned}\\
    %%
  \TRANS[\text{(assign)}]{par/or-adv2}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr
               (\uline{\Nop;\ddd\AtLoop\ddd;\Restore(1);\ddd)};}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,1)\}]\rangle\\
    \end{aligned}\\
    %%
  \TRANS[\text{(seq-nop)}]{par/or-adv2}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr(\AwaitExt(\evtrecv);\ddd}\\[-\jot]
             &\ceu{\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,1)\}]\rangle\\
    \end{aligned}\\
  \shortintertext{(both sides are now blocked and
    the next transition ends the reaction)}
  \TRANS{pop}\null&
    \begin{aligned}[t]
      \langle&\ceu{(\ddd)\AtParOr(\AwaitExt(\evtrecv);\ddd}\\[-\jot]
             &\ceu{\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},0,\nil,[\{(\led,1)\}]\rangle\\
    \end{aligned}
\end{align*}

So, the bootstrap reaction terminates in a memory where variable~$\led$ is
set to~$1$ with both sides of the $\ceu{\AtParOr}$ blocked
on~$\ceu{\AwaitExt}$ statements: the left-hand side waiting on~$\evtbttn$
and the right hand-side waiting on~$\evtrecv$.

(This is a general property of reactions.  Every reaction eventually blocks
in~$\ceu{\AwaitExt}$, $\ceu{\AwaitInt}$, $\ceu{\Every}$, $\ceu{\Fin}$,
or~$\ceu{\RunAt}$ statements in parallel trails.  If none of these trails is
blocked in a~$\ceu{\RunAt}$, then the program can no longer advance and the
reaction is terminated.)

The second reaction is a reaction to event~$\evtrecv$.  It starts with the
description produced by the previous reaction but with~$\nil$ replaced
by~$\evtrecv$, i.e.,
\begin{align*}
  \langle&\ceu{(\ddd)\AtParOr
           (\AwaitExt(\evtrecv);\ddd}\\[-\jot]
         &\ceu{\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
         &\ceu{\Restore(1);\Restore(0)},0,\evtrecv,[\{(\led,1)\}]\rangle,
\end{align*}
and after four transitions results in:
\begin{align*}
  \langle&\ceu{(\ddd)\AtParOr
           (\AwaitExt(\evtrecv)}\\[-\jot]
         &\ceu{\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
         &\ceu{\Restore(1);\Restore(0)},0,\nil,[\{(\led,0)\}]\rangle.
\end{align*}

The third and final reaction is a reaction to event~$\evtbttn$.  It starts
with the description
\begin{align*}
  \langle&\ceu{\AwaitExt(\evtbttn)\AtParOr
           (\AwaitExt(\evtrecv)}\\[-1\jot]
         &\ceu{\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
         &\ceu{\Restore(1);\Restore(0)},0,\evtbttn,[\{(\led,0)\}]\rangle.
\end{align*}
and proceeds as follows:
\begin{align*}
  \TRANS{push}\null&
    \begin{aligned}[t]
      \langle&\ceu{\uline{\Nop}\AtParOr\,\null(\AwaitExt(\evtrecv)}\\[-\jot]
             &\ceu{\AtLoop\ddd;\Restore(1);\ddd);}\\[-\jot]
             &\ceu{\Restore(1);\Restore(0)},1,\nil,[\{(\led,0)\}]\rangle
    \end{aligned}\\
    %%
  \shortintertext{(the next transition terminates the $\ceu{\AtParOr}$
    and aborts its right-hand side; ``$\led\coloneqq0$'' is
    the result of the call to~$\clear$)}
  \TRANS{par/or-nop1}\null&
    \<\ceu{\uline{\led\coloneqq0};\Restore(1);\Restore(0)},
    1,\nil,[\{(\led,0)\}]>\\
    %%
  \TRANS[\text{(assign)}]{seq-adv}\null&
    \<\ceu{\uline{\Nop};\Restore(1);\Restore(0)},1,\nil,[\{(\led,0)\}]>\\
    %%
  \TRANS{seq-nop}\null&
    \<\ceu{\uline{\Restore(1)};\Restore(0)},1,\nil,[\{(\led,0)\}]>\\
    %%
  \TRANS[\text{(restore)}]{seq-adv}\null&
    \<\ceu{\uline{\Nop};\Restore(0)},1,\nil,[\{(\led,0)\}]>\\
    %%
  \TRANS{seq-nop}\null&
    \<\ceu{\uline{\Restore(0)}},1,\nil,[\{(\led,0)\}]>\\
    %%
  \TRANS{restore}\null&
    \<\ceu{\uline{\Nop}},1,\nil,[]>\\
    %%
  \TRANS{pop}\null&
    \<\ceu{\uline{\Nop}},0,\nil,[]>
\end{align*}

After the third reaction the program is terminated (consists of a single
$\ceu{\Nop}$) and no longer responds to the environment.

\endgroup

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "index.tex"
%%% End:
